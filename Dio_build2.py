import numpy as np
import matplotlib.pyplot as plt

# 使用 np.lib.scimath.arcsin 处理超出 [-1,1] 的情况，返回复数解
asin_complex = np.lib.scimath.arcsin

def compute_coeffs(theta_inc, rho1, cP1, cS1, rho2, cP2, cS2):
    '''
    Given the long-wave incident angle theta_inc (unit: radians) and the parameters of the two media,
    Use the matrix equations in the literature to solve the reflection and transmission amplitude coefficients:
    - R_P: Long-wave amplitude coefficient generated by incident long-wave reflection
    - R_S: Shear wave amplitude coefficient generated by incident long-wave reflection
    - T_P: Long-wave amplitude coefficient generated by transmission
    - T_S: Shear wave amplitude coefficient generated by transmission
    All calculations use complex operations.
    '''

    # The angle of incidence in medium 1 is theta_inc
    theta_P1 = theta_inc
    # Calculate the sine and cosine of the incident long wave in water
    sin_P1 = np.sin(theta_P1)
    cos_P1 = np.cos(theta_P1)
    
    # Calculate other angles according to Snell's law (using complex arcsin function):
    # Long wave angle in medium 2 (P wave)
    arg_P2 = (cP2 / cP1) * sin_P1
    theta_P2 = asin_complex(arg_P2)
    # Shear wave angle in medium 1 
    # (although shear waves cannot propagate in water, 
    # the complex number cS1 is used here to approximate its attenuation characteristics)
    arg_S1 = (cS1 / cP1) * sin_P1
    theta_S1 = asin_complex(arg_S1)
    # Shear wave angle in medium 2
    arg_S2 = (cS2 / cP1) * sin_P1
    theta_S2 = asin_complex(arg_S2)
    
    # Construct a 4x4 coefficient matrix M 
    # (all operations are complex)
    M = np.array([
        [ np.sin(theta_P1)/(rho1*cP1),          np.cos(theta_S1)/(rho1*cS1),        -np.sin(theta_P2)/(rho2*cP2),           np.sin(theta_S2)/(rho2*cS2) ],
        [ np.cos(theta_P1)/(rho1*cP1),         -np.sin(theta_S1)/(rho1*cS1),         np.cos(theta_P2)/(rho2*cP2),           np.sin(theta_S2)/(rho2*cS2) ],
        [ -np.cos(2*theta_S1),                  np.sin(2*theta_S1),                  np.cos(2*theta_S2),                    np.sin(2*theta_S2) ],
        [ np.sin(2*theta_P1)/(cP1**2/cS1**2),   np.cos(2*theta_S1),                  np.sin(2*theta_P2)/(cP2**2/cS2**2),   -np.cos(2*theta_S2) ]
    ], dtype=np.complex128)
    
    # Construct the right side vector b
    b = np.array([
         -np.sin(theta_P1)/(rho1*cP1),
          np.cos(theta_P1)/(rho1*cP1),
          np.cos(2*theta_S1),
          np.sin(2*theta_P1)/(cP1**2/cS1**2)
    ], dtype=np.complex128)
    
    # Solve the linear system of equations M * [R_P, R_S, T_P, T_S]^T = b
    X = np.linalg.solve(M, b)

    # Define the angular impedance of each mode in each medium (Equation (3))
    Z_P1 = (cP1 * rho1) / np.cos(theta_P1)
    Z_P2 = (cP2 * rho2) / np.cos(theta_P2)
    Z_S1 = (cS1 * rho1) / np.cos(theta_S1)
    Z_S2 = (cS2 * rho2) / np.cos(theta_S2)



    return X, theta_P2, theta_S1, theta_S2

# ---------------------
# Set medium parameters (water – aluminum parameters in the literature)
rho1 = 1000 # Water density [kg/m^3]
cP1 = 1480 # Long wave velocity in water [m/s]
cS1 = 0.0013 + 0.0013j # Shear wave velocity of water in the model (using complex numbers to describe its strong attenuation)

rho2 = 2700 # Aluminum density [kg/m^3]
cP2 = 6420 # Long wave velocity in aluminum [m/s]
cS2 = 3040 # Shear wave velocity in aluminum [m/s]

# Build an array of incident angles (0 to 90 degrees, converted to radians)
angles_deg = np.linspace(0, 90, 181)    # One point every 0.5 degrees
angles_rad = np.deg2rad(angles_deg)

# Define an array to store the amplitude coefficient at each angle
# Initialize the array to store the amplitude coefficient (complex number) 
# and energy (power) coefficient
R_P_arr = np.zeros_like(angles_rad, dtype=np.complex128)
R_S_arr = np.zeros_like(angles_rad, dtype=np.complex128)
T_P_arr = np.zeros_like(angles_rad, dtype=np.complex128)
T_S_arr = np.zeros_like(angles_rad, dtype=np.complex128)

R_P_energy_arr = np.zeros_like(angles_rad, dtype=np.float64)
R_S_energy_arr = np.zeros_like(angles_rad, dtype=np.float64)
T_P_energy_arr = np.zeros_like(angles_rad, dtype=np.float64)
T_S_energy_arr = np.zeros_like(angles_rad, dtype=np.float64)


# Calculate the amplitude coefficient for each incident angle loop
for i, theta in enumerate(angles_rad):
    X, thetaP2, thetaS1, thetaS2 = compute_coeffs(theta, rho1, cP1, cS1, rho2, cP2, cS2)
    
    R_P, R_S, T_P, T_S = X[0], X[1], X[2], X[3]

    R_P_arr[i] = R_P
    R_S_arr[i] = R_S
    T_P_arr[i] = T_P
    T_S_arr[i] = T_S

    # Calculate the "angular impedance" corresponding to each mode, 
    # and use the incident angle of the corresponding wave
    # Long wave impedance in medium 1
    Z_P1 = (cP1 * rho1) / np.cos(theta)
    
    Z_P2 = (cP2 * rho2) / np.cos(thetaP2)
    
    Z_S1 = (cS1 * rho1) / np.cos(thetaS1)
    
    Z_S2 = (cS2 * rho2) / np.cos(thetaS2)

    denom = np.real(1/np.conjugate(Z_P1))

    # Calculate the power coefficient (energy coefficient), 
    # pay attention to the complex conjugate operation defined in the formula
    R_P_energy = (R_P * np.conjugate(R_P)).real
    R_S_energy = (R_S * np.conjugate(R_S)).real * (np.real(1/np.conjugate(Z_S1)) / denom)
    T_P_energy = (T_P * np.conjugate(T_P)).real * (np.real(1/np.conjugate(Z_P2)) / denom)
    T_S_energy = (T_S * np.conjugate(T_S)).real * (np.real(1/np.conjugate(Z_S2)) / denom)
    
    R_P_energy_arr[i] = R_P_energy
    R_S_energy_arr[i] = R_S_energy
    T_P_energy_arr[i] = T_P_energy
    T_S_energy_arr[i] = T_S_energy

plt.figure(figsize=(6, 5))
plt.plot(angles_deg, R_P_energy_arr, label=r'$R^I_L$', linewidth=2)
plt.plot(angles_deg, R_S_energy_arr, label=r'$R^I_S$', linewidth=2)
plt.plot(angles_deg, T_P_energy_arr, label=r'$T^I_L$', linewidth=2)
plt.plot(angles_deg, T_S_energy_arr, label=r'$T^I_S$', linewidth=2)
plt.xlabel("incident angle (°)", fontsize=14)
plt.ylabel("intensity coefficient", fontsize=14)
plt.title("Water-Aluminum Interface", fontsize=16)
plt.legend(fontsize=12)
plt.xlim(0, 90)
plt.ylim(0, 1.1)
plt.grid(True)
plt.show()
